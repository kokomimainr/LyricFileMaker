const { User } = require("../../db/models");
const bcrypt = require("bcrypt");
const nodemailer = require("nodemailer");
const jwt = require("jsonwebtoken");

class UserService {
  async signUp(username, email, password) {
    try {

      const isCreated = await User.findOne({ where: { email } });
      if (isCreated) {
        throw new Error("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω");
      }

      if (email === process.env.EMAIL_USER) {
        await User.create({
          username,
          email,
          isAdmin: true,
          password: await bcrypt.hash(password, 10),
        });
      }
      const transporter = nodemailer.createTransport({
        host: "smtp.mail.ru",
        port: 465,
        secure: true,
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASS,
        },
      });

      await transporter.sendMail({
        from: `"üëª" <${process.env.EMAIL_USER}>`,
        to: email,
        subject: "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ Lyric File Maker!",
        html: `<div style="text-align: center;">
    <h1>–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, ${username}!</h1>

<p> –°–ø–∞—Å–∏–±–æ –∑–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –Ω–∞ <a href=${process.env.CLIENT_URL}>Lyric File Maker</a>! <br/><br/>

–ú—ã —Ä–∞–¥—ã –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –≤–∞—Å –≤ –Ω–∞—à–µ–º —Å–æ–æ–±—â–µ—Å—Ç–≤–µ.<br/>

–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≤–æ–π—Ç–∏ –≤ —Å–≤–æ—é —É—á–µ—Ç–Ω—É—é –∑–∞–ø–∏—Å—å –∏ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤—Å–µ–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏ –Ω–∞—à–µ–≥–æ —Å–∞–π—Ç–∞.<br/>

–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –Ω—É–∂–Ω–∞ –ø–æ–º–æ—â—å, –Ω–µ —Å—Ç–µ—Å–Ω—è–π—Ç–µ—Å—å –æ–±—Ä–∞—â–∞—Ç—å—Å—è –≤ –Ω–∞—à—É —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏.<br/>
<br/>

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,  <br/>
–ö–æ–º–∞–Ω–¥–∞ LFM</p></div>`,
      });

      const user = await User.create({
        username,
        email,
        password: await bcrypt.hash(password, 10),
      });

      const plainUser = user.get();
      delete plainUser.password;

      return { user: plainUser };
    } catch (error) {
      let err ;
      error.message === "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω" ? err = error.message : err = "–¢–∞–∫–æ–π —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –ø–æ—á—Ç—ã –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç";
      throw new Error(err);
    }
  }

  async signIn(email, password) {
    const user = await User.findOne({ where: { email } });
    if (!user) throw new Error("User not found");

    const isCorrectPassword = await bcrypt.compare(password, user.password);
    if (!isCorrectPassword) throw new Error("–ù–µ–≤–µ—Ä–Ω—ã–π –∞–¥—Ä–µ—Å —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –ø–æ—á—Ç—ã –∏–ª–∏ –ø–∞—Ä–æ–ª—å");

    const plainUser = user.get();
    delete plainUser.password;

    return { user: plainUser };
  }

  async updateUser({ id, username, email, avatar }) {
    try {
      const user = await User.findOne({ where: { id } });

      if (user) {
        user.username = username;
        user.email = email;
        if (avatar !== "") {
          user.avatar = avatar;
        }

        await user.save();
        return user;
      } else {
        return null;
      }
    } catch (error) {
      console.error(error);
      throw new Error("–ü—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.");
    }
  }

  async requestPasswordReset(email) {
    const user = await User.findOne({ where: { email } });
    if (!user) throw new Error("User not found");

    const token = jwt.sign({ email }, process.env.JWT_SECRET, {
      expiresIn: "1h",
    });

    const resetLink = `${process.env.CLIENT_URL}/reset-password/${token}`;

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Nodemailer
    const transporter = nodemailer.createTransport({
      host: "smtp.mail.ru",
      port: 465,
      secure: true,
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    await transporter.sendMail({
      from: `"üëª" <${process.env.EMAIL_USER}>`,
      to: email,
      subject: "–°–±—Ä–æ—Å –ø–∞—Ä–æ–ª—è LFM",
      html: `<div style="text-align: center;">
      <h1>–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, ${user.username}!</h1>

<p>–ú—ã –ø–æ–ª—É—á–∏–ª–∏ –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–±—Ä–æ—Å –ø–∞—Ä–æ–ª—è –¥–ª—è –≤–∞—à–µ–π —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ –Ω–∞ <a href=${process.env.CLIENT_URL}>Lyric File Maker</a>.<br/>
<br/>

–ß—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å–ª–µ–¥—É—é—â–µ–π —Å—Å—ã–ª–∫–µ:<br/>

<button style="border-radius: 5px; border: 1px solid #ccc; padding: 10px; background-color: #FE9FAD; font-size: 15px; margin: 20px 0px;">
  <a href="${resetLink}" style="text-decoration: none; color: #ffebeb; transition: 0.3s ease-in-out;">
    –°–±—Ä–æ—Å–∏—Ç—å –ø–∞—Ä–æ–ª—å
  </a>
</button>
<br/><br/>

–≠—Ç–∞ —Å—Å—ã–ª–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –≤ —Ç–µ—á–µ–Ω–∏–µ 24 —á–∞—Å–æ–≤. –ï—Å–ª–∏ –≤—ã –Ω–µ –∑–∞–ø—Ä–∞—à–∏–≤–∞–ª–∏ —Å–±—Ä–æ—Å –ø–∞—Ä–æ–ª—è, –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä—É–π—Ç–µ —ç—Ç–æ –ø–∏—Å—å–º–æ.<br/>

–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –∫–∞–∫–∏–µ-–ª–∏–±–æ –≤–æ–ø—Ä–æ—Å—ã, –Ω–µ —Å—Ç–µ—Å–Ω—è–π—Ç–µ—Å—å –æ–±—Ä–∞—â–∞—Ç—å—Å—è –≤ –Ω–∞—à—É —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏.<br/><br/>

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,  <br/>
–ö–æ–º–∞–Ω–¥–∞ LFM</p></div>`,
    });
  }
  async resetPassword(token, newPassword) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findOne({ where: { email: decoded.email } });
      if (!user) throw new Error("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω");

      const hashedPassword = await bcrypt.hash(newPassword, 10);
      await user.update({ password: hashedPassword });
    } catch (error) {
      throw new Error("Invalid or expired token");
    }
  }
}

module.exports = new UserService();
